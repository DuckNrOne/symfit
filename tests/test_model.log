============================= test session starts =============================
platform win32 -- Python 3.7.3, pytest-4.3.1, py-1.8.0, pluggy-0.9.0 -- C:\Users\Antony\Anaconda3\python.exe
cachedir: .pytest_cache
rootdir: C:\Users\Antony\Projects\Symfit, inifile: pytest.ini
plugins: remotedata-0.3.1, openfiles-0.3.2, doctestplus-0.3.0, arraydiff-0.3
collecting ... collected 9 items

test_model_py.py::test_model_as_dict PASSED                              [ 11%]
test_model_py.py::test_order PASSED                                      [ 22%]
test_model_py.py::test_neg PASSED                                        [ 33%]
test_model_py.py::test_CallableNumericalModel FAILED                     [ 44%]
test_model_py.py::test_CallableNumericalModel2D FAILED                   [ 55%]
test_model_py.py::test_pickle PASSED                                     [ 66%]
test_model_py.py::test_MatrixSymbolModel FAILED                          [ 77%]
test_model_py.py::test_interdependency_invalid PASSED                    [ 88%]
test_model_py.py::test_interdependency PASSED                            [100%]

================================== FAILURES ===================================
_________________________ test_CallableNumericalModel _________________________

    def test_CallableNumericalModel():
        x, y, z = variables('x, y, z')
        a, b = parameters('a, b')
    
        model = CallableModel({y: a * x + b})
        numerical_model = CallableNumericalModel(
            {y: lambda x, a, b: a * x + b}, [x], [a, b]
        )
        assert model.__signature__ == numerical_model.__signature__
    
        xdata = np.linspace(0, 10)
        ydata = model(x=xdata, a=5.5, b=15.0).y + np.random.normal(0, 1)
        np.testing.assert_almost_equal(
            model(x=xdata, a=5.5, b=15.0),
            numerical_model(x=xdata, a=5.5, b=15.0),
        )
    
        faulty_model = CallableNumericalModel({y: lambda x, a, b: a * x + b},
                                                [], [a, b])
        assert not model.__signature__ == faulty_model.__signature__
    
        try:
            # This is an incorrect signature, even though the lambda function is
            # correct. Should fail.
            faulty_model(xdata, 5.5, 15.0)
            assert False
        except TypeError:
            assert True
    
        # Faulty model whose components do not all accept all of the args
        faulty_model = CallableNumericalModel(
            {y: lambda x, a, b: a * x + b, z: lambda x, a: x**a}, [x], [a, b]
        )
        assert model.__signature__ == faulty_model.__signature__
        try:
            # Lambda got an unexpected keyword 'b'
            faulty_model(xdata, 5.5, 15.0)
            assert False
        except TypeError:
            assert True
    
        # Faulty model with a wrongly named argument
        faulty_model = CallableNumericalModel(
            {y: lambda x, a, c=5: a * x + c}, [x], [a, b]
        )
        assert model.__signature__ == faulty_model.__signature__
        try:
            # Lambda got an unexpected keyword 'b'
            faulty_model(xdata, 5.5, 15.0)
            assert False
        except TypeError:
            assert True
    
        # Correct version of the previous model
        numerical_model = CallableNumericalModel(
            {y: lambda x, a, b: a * x + b, z: lambda x, a: x ** a},
            connectivity_mapping={y: {a, b, x}, z: {x, a}}
        )
        # Correct version of the previous model
        mixed_model = CallableNumericalModel(
            {y: lambda x, a, b: a * x + b, z: x ** a}, [x],
            [a, b]
        )
        np.testing.assert_almost_equal(
            numerical_model(x=xdata, a=5.5, b=15.0),
            mixed_model(x=xdata, a=5.5, b=15.0)
        )
        zdata = mixed_model(x=xdata, a=5.5, b=15.0).z + np.random.normal(0, 1)
    
        # Check if the fits are the same
        fit = Fit(mixed_model, x=xdata, y=ydata, z=zdata)
        mixed_result = fit.execute()
        fit = Fit(numerical_model, x=xdata, y=ydata, z=zdata)
        numerical_result = fit.execute()
        for param in [a, b]:
>           if mixed_result.value(param) is None & numerical_result.value(param) is None:
E           TypeError: unsupported operand type(s) for &: 'NoneType' and 'float'

test_model_py.py:172: TypeError
________________________ test_CallableNumericalModel2D ________________________

    def test_CallableNumericalModel2D():
        """
        Apply a CallableNumericalModel to 2D data, to see if it is
        agnostic to data shape.
        """
        shape = (30, 40)
    
        def function(a, b):
            out = np.ones(shape) * a
            out[15:, :] += b
            return out
    
        a, b = parameters('a, b')
        y, = variables('y')
    
        model = CallableNumericalModel({y: function}, [], [a, b])
        data = 15 * np.ones(shape)
        data[15:, :] += 20
    
        fit = Fit(model, y=data)
        fit_result = fit.execute()
        assert fit_result.value(a) == pytest.approx(15)
        assert fit_result.value(b) == pytest.approx(20)
    
        def flattened_function(a, b):
            out = np.ones(shape) * a
            out[15:, :] += b
            return out.flatten()
    
        model = CallableNumericalModel({y: flattened_function}, [], [a, b])
        data = 15 * np.ones(shape)
        data[15:, :] += 20
        data = data.flatten()
    
        fit = Fit(model, y=data)
        flat_result = fit.execute()
    
        assert fit_result.value(a) == pytest.approx(flat_result.value(a))
        assert fit_result.value(b) == pytest.approx(flat_result.value(b))
>       assert fit_result.stdev(a) == pytest.approx(flat_result.stdev(a))
E       TypeError: cannot make approximate comparisons to non-numeric values: None

test_model_py.py:225: TypeError
___________________________ test_MatrixSymbolModel ____________________________

    def test_MatrixSymbolModel():
        """
        Test a model which is defined by ModelSymbols, see #194
        """
        N = Symbol('N', integer=True)
        M = MatrixSymbol('M', N, N)
        W = MatrixSymbol('W', N, N)
        I = MatrixSymbol('I', N, N)
        y = MatrixSymbol('y', N, 1)
        c = MatrixSymbol('c', N, 1)
        a, b = parameters('a, b')
        z, x = variables('z, x')
    
        model_dict = {
            W: Inverse(I + M / a ** 2),
            c: - W * y,
            z: sqrt(c.T * c)
        }
        # TODO: This should be a Model in the future, but sympy is not yet
        # capable of computing Matrix derivatives at the time of writing.
        model = CallableModel(model_dict)
    
        assert model.params == [a]
        assert model.independent_vars == [I, M, y]
        assert model.dependent_vars == [z]
        assert model.interdependent_vars == [W, c]
        assert model.connectivity_mapping == {W: {I, M, a}, c: {W, y}, z: {c}}
        # Generate data
        iden = np.eye(2)
        M_mat = np.array([[2, 1], [3, 4]])
        y_vec = np.array([3, 5])
    
>       eval_model = model(I=iden, M=M_mat, y=y_vec, a=0.1)

test_model_py.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\symfit\core\models.py:616: in __call__
    return Ans(*self.eval_components(*args, **kwargs))
..\symfit\core\models.py:564: in eval_components
    kwargs[symbol.name] = components[symbol](**dependencies_kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

I = array([[1., 0.],
       [0., 1.]]), M = array([[2, 1],
       [3, 4]])
a = 0.1

    def _lambdifygenerated(I, M, a):
>       return (inv((a**(-2)).dot(M) + I))
E       NameError: name 'inv' is not defined

<lambdifygenerated-3>:2: NameError
============================== warnings summary ===============================
C:\Users\Antony\Projects\Symfit\symfit\core\fit.py:1
  C:\Users\Antony\Projects\Symfit\symfit\core\fit.py:1: DeprecationWarning: Using or importing the ABCs from 'collections' instead of from 'collections.abc' is deprecated, and in 3.8 it will stop working
    from collections import OrderedDict, Sequence

C:\Users\Antony\Projects\Symfit\symfit\core\models.py:1
  C:\Users\Antony\Projects\Symfit\symfit\core\models.py:1: DeprecationWarning: Using or importing the ABCs from 'collections' instead of from 'collections.abc' is deprecated, and in 3.8 it will stop working
    from collections import namedtuple, Mapping, OrderedDict

tests/test_model_py.py::test_neg
tests/test_model_py.py::test_pickle
  C:\Users\Antony\Projects\Symfit\symfit\core\models.py:89: DeprecationWarning: It is recommended to provide names to Variable explicitly as automatic generation of names will be dropped in future `symfit` versions.
    model = {Variable(): expr for expr in model}

tests/test_model_py.py::test_CallableNumericalModel
tests/test_model_py.py::test_CallableNumericalModel
tests/test_model_py.py::test_CallableNumericalModel
tests/test_model_py.py::test_CallableNumericalModel
tests/test_model_py.py::test_CallableNumericalModel
tests/test_model_py.py::test_CallableNumericalModel2D
tests/test_model_py.py::test_CallableNumericalModel2D
tests/test_model_py.py::test_pickle
  C:\Users\Antony\Projects\Symfit\symfit\core\models.py:491: DeprecationWarning: `independent_vars` and `params` have been deprecated. Use `connectivity_mapping` instead.
    '`independent_vars` and `params` have been deprecated.'

-- Docs: https://docs.pytest.org/en/latest/warnings.html
=============== 3 failed, 6 passed, 12 warnings in 1.68 seconds ===============
============================= test session starts =============================
platform win32 -- Python 3.7.3, pytest-4.3.1, py-1.8.0, pluggy-0.9.0 -- C:\Users\Antony\Anaconda3\python.exe
cachedir: .pytest_cache
rootdir: C:\Users\Antony\Projects\Symfit, inifile: pytest.ini
plugins: remotedata-0.3.1, openfiles-0.3.2, doctestplus-0.3.0, arraydiff-0.3
collecting ... collected 0 items / 1 errors

=================================== ERRORS ====================================
___________________ ERROR collecting tests/test_model_py.py ___________________
..\..\..\Anaconda3\lib\site-packages\_pytest\python.py:499: in _importtestmodule
    mod = self.fspath.pyimport(ensuresyspath=importmode)
..\..\..\Anaconda3\lib\site-packages\py\_path\local.py:701: in pyimport
    __import__(modname)
E     File "C:\Users\Antony\Projects\Symfit\tests\test_model_py.py", line 433
E       ============================= test session starts =============================
E        ^
E   SyntaxError: invalid syntax
!!!!!!!!!!!!!!!!!!! Interrupted: 1 errors during collection !!!!!!!!!!!!!!!!!!!
=========================== 1 error in 0.13 seconds ===========================
